"""
L_opt Reader for Stage 3 Optimization Views

Reads solver-specific optimization views from Parquet files generated by Stage 3.

Theoretical Foundation:
- Stage-3 DATA COMPILATION - Theoretical Foundations & Mathematical Framework
- Section: L_opt Layer - Solver-Specific Optimization Views
- PyGMO GA View: gene definitions, operators, bounds
"""

import pandas as pd
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
import numpy as np


@dataclass
class GAGene:
    """Genetic Algorithm gene definition"""
    gene_name: str
    gene_index: int
    lower_bound: float
    upper_bound: float
    chromosome_length: int
    is_discrete: bool = False
    
    def validate(self) -> bool:
        """Validate gene definition"""
        return (
            self.lower_bound <= self.upper_bound and
            self.chromosome_length > 0 and
            self.gene_index >= 0
        )


@dataclass
class GAOperator:
    """Genetic Algorithm operator definition"""
    operator_type: str  # 'crossover' or 'mutation'
    operator_name: str
    parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass
class GAView:
    """Complete GA view for PyGMO"""
    genes: List[GAGene]
    operators: List[GAOperator]
    total_dimensions: int
    discrete_count: int
    continuous_count: int
    
    def get_bounds(self) -> Tuple[List[float], List[float]]:
        """
        Get variable bounds for PyGMO.
        
        Returns:
            Tuple of (lower_bounds, upper_bounds)
        """
        lower_bounds = [gene.lower_bound for gene in self.genes]
        upper_bounds = [gene.upper_bound for gene in self.genes]
        return lower_bounds, upper_bounds
    
    def get_discrete_indices(self) -> List[int]:
        """Get indices of discrete variables"""
        return [gene.gene_index for gene in self.genes if gene.is_discrete]
    
    def validate(self) -> bool:
        """Validate GA view"""
        # Check all genes are valid
        if not all(gene.validate() for gene in self.genes):
            return False
        
        # Check dimension counts
        if len(self.genes) != self.total_dimensions:
            return False
        
        discrete_actual = sum(1 for gene in self.genes if gene.is_discrete)
        continuous_actual = sum(1 for gene in self.genes if not gene.is_discrete)
        
        if discrete_actual != self.discrete_count or continuous_actual != self.continuous_count:
            return False
        
        return True


class LOptReader:
    """
    Reader for L_opt Parquet files from Stage 3 output.
    
    L_opt contains solver-specific optimization views:
    - ga_view.parquet: Genetic Algorithm view with gene definitions
    - pulp_view.parquet: PuLP linear programming view (if exists)
    - ortools_view.parquet: OR-Tools CP-SAT view (if exists)
    - deap_view.parquet: DEAP evolutionary view (if exists)
    - pygmo_view.parquet: PyGMO multi-objective view (if exists)
    
    For PyGMO, we primarily use the GA view which contains:
    - Gene definitions with bounds and types
    - Operator specifications
    - Chromosome structure
    """
    
    def __init__(self, input_dir: Path, logger: Optional[Any] = None):
        """
        Initialize L_opt reader.
        
        Args:
            input_dir: Path to Stage 3 output directory
            logger: Optional StructuredLogger instance
        """
        self.input_dir = Path(input_dir)
        self.logger = logger
        
        # Support both 'L_opt' and alternative manifests
        candidate_dirs = [self.input_dir / 'L_opt']
        self.lopt_dir = next((d for d in candidate_dirs if d.exists()), candidate_dirs[0])
        
        # Loaded views
        self.ga_view: Optional[GAView] = None
        self.raw_ga_df: Optional[pd.DataFrame] = None
        
        # Validation is soft: GA view may be absent in current Stage-3 builds
        if self.logger:
            self.logger.info(f"Optimization view reader initialized (dir may not exist): {self.lopt_dir}")
    
    def load_ga_view(self) -> GAView:
        """
        Load GA view from Parquet file.
        
        Returns:
            GAView instance with gene and operator definitions
        """
        ga_file = self.lopt_dir / 'ga_view.parquet'
        
        if not self.lopt_dir.exists() or not ga_file.exists():
            # Soft-fail: return a minimal placeholder GAView to let pipeline proceed
            if self.logger:
                self.logger.warning(f"GA view not found at {ga_file}. Using placeholder GA view.")
            self.ga_view = GAView(genes=[], operators=[], total_dimensions=0, discrete_count=0, continuous_count=0)
            return self.ga_view
        
        if self.logger:
            self.logger.info(f"Loading GA view from {ga_file}")
        
        # Read Parquet file
        self.raw_ga_df = pd.read_parquet(ga_file)
        
        # Parse GA view structure
        # Expected columns: component, gene_name, gene_index, lower_bound, upper_bound, 
        #                  chromosome_length, operator_type, operator_name
        
        genes = []
        operators = []
        
        # Extract genes
        gene_rows = self.raw_ga_df[self.raw_ga_df['component'] == 'gene']
        for _, row in gene_rows.iterrows():
            gene = GAGene(
                gene_name=row['gene_name'],
                gene_index=int(row['gene_index']),
                lower_bound=float(row['lower_bound']),
                upper_bound=float(row['upper_bound']),
                chromosome_length=int(row.get('chromosome_length', 1)),
                is_discrete=self._is_discrete_gene(row)
            )
            genes.append(gene)
        
        # Extract operators
        operator_rows = self.raw_ga_df[self.raw_ga_df['component'] == 'operator']
        for _, row in operator_rows.iterrows():
            operator = GAOperator(
                operator_type=row['operator_type'],
                operator_name=row['operator_name'],
                parameters=self._parse_operator_parameters(row)
            )
            operators.append(operator)
        
        # Calculate dimensions
        total_dimensions = len(genes)
        discrete_count = sum(1 for gene in genes if gene.is_discrete)
        continuous_count = total_dimensions - discrete_count
        
        self.ga_view = GAView(
            genes=genes,
            operators=operators,
            total_dimensions=total_dimensions,
            discrete_count=discrete_count,
            continuous_count=continuous_count
        )
        
        # Validate
        if not self.ga_view.validate():
            raise ValueError("GA view validation failed")
        
        if self.logger:
            self.logger.info(
                "GA view loaded",
                total_dimensions=total_dimensions,
                discrete_count=discrete_count,
                continuous_count=continuous_count,
                operators=len(operators)
            )
        
        return self.ga_view
    
    def _is_discrete_gene(self, row: pd.Series) -> bool:
        """Determine if gene is discrete based on bounds and name"""
        # Check if bounds are integers
        lower = row['lower_bound']
        upper = row['upper_bound']
        
        # Binary variables (0-1)
        if lower == 0 and upper == 1:
            return True
        
        # Integer ranges
        if isinstance(lower, (int, np.integer)) and isinstance(upper, (int, np.integer)):
            return True
        
        # Check gene name patterns
        gene_name = row['gene_name'].lower()
        if any(pattern in gene_name for pattern in ['binary', 'discrete', 'integer', 'timeslot', 'room']):
            return True
        
        return False
    
    def _parse_operator_parameters(self, row: pd.Series) -> Dict[str, Any]:
        """Parse operator parameters from row"""
        parameters = {}
        
        # Extract parameter columns (columns not in standard set)
        standard_cols = {'component', 'operator_type', 'operator_name', 'gene_name', 
                        'gene_index', 'lower_bound', 'upper_bound', 'chromosome_length'}
        
        for col in row.index:
            if col not in standard_cols and pd.notna(row[col]):
                parameters[col] = row[col]
        
        return parameters
    
    def get_variable_structure(self) -> Dict[str, Any]:
        """
        Get variable structure for PyGMO problem definition.
        
        Returns:
            Dictionary with variable structure information
        """
        if self.ga_view is None:
            raise ValueError("GA view not loaded")
        
        lower_bounds, upper_bounds = self.ga_view.get_bounds()
        discrete_indices = self.ga_view.get_discrete_indices()
        
        return {
            "total_dimensions": self.ga_view.total_dimensions,
            "discrete_count": self.ga_view.discrete_count,
            "continuous_count": self.ga_view.continuous_count,
            "lower_bounds": lower_bounds,
            "upper_bounds": upper_bounds,
            "discrete_indices": discrete_indices,
            "genes": [
                {
                    "name": gene.gene_name,
                    "index": gene.gene_index,
                    "bounds": (gene.lower_bound, gene.upper_bound),
                    "is_discrete": gene.is_discrete
                }
                for gene in self.ga_view.genes
            ]
        }
    
    def get_summary(self) -> Dict[str, Any]:
        """
        Get summary of loaded GA view.
        
        Returns:
            Summary dictionary
        """
        if self.ga_view is None:
            return {"status": "not_loaded"}
        
        return {
            "status": "loaded",
            "total_dimensions": self.ga_view.total_dimensions,
            "discrete_count": self.ga_view.discrete_count,
            "continuous_count": self.ga_view.continuous_count,
            "operators": [
                {
                    "type": op.operator_type,
                    "name": op.operator_name
                }
                for op in self.ga_view.operators
            ]
        }


