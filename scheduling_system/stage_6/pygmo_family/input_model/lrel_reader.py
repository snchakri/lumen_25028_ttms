"""
L_rel Reader for Stage 3 Relationship Graph

Reads relationship graph from GraphML file generated by Stage 3.

Theoretical Foundation:
- Stage-3 DATA COMPILATION - Theoretical Foundations & Mathematical Framework
- Section: L_rel Layer - Relationship Graph
"""

import networkx as nx
from pathlib import Path
from typing import Dict, List, Optional, Any, Set, Tuple
from dataclasses import dataclass


@dataclass
class RelationshipMetrics:
    """Metrics for relationship graph"""
    node_count: int
    edge_count: int
    relationship_types: Set[str]
    average_degree: float
    density: float
    is_connected: bool
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "node_count": self.node_count,
            "edge_count": self.edge_count,
            "relationship_types": list(self.relationship_types),
            "average_degree": self.average_degree,
            "density": self.density,
            "is_connected": self.is_connected,
        }


class LRelReader:
    """
    Reader for L_rel GraphML file from Stage 3 output.
    
    L_rel contains the complete relationship graph with:
    - Nodes: All entities with their IDs and types
    - Edges: Relationships between entities with weights and types
    - Attributes: Relationship metadata (strength, type, constraints)
    
    The graph represents the complete relational structure of the
    scheduling problem, including:
    - Hierarchical relationships (institution → department → program → course)
    - Assignment relationships (faculty → course, course → room)
    - Enrollment relationships (student → batch → course)
    - Constraint relationships (precedence, conflicts, preferences)
    """
    
    def __init__(self, input_dir: Path, logger: Optional[Any] = None):
        """
        Initialize L_rel reader.
        
        Args:
            input_dir: Path to Stage 3 output directory
            logger: Optional StructuredLogger instance
        """
        self.input_dir = Path(input_dir)
        self.lrel_dir = self.input_dir / 'L_rel'
        self.logger = logger
        
        # Relationship graph
        self.graph: Optional[nx.Graph] = None
        self.metrics: Optional[RelationshipMetrics] = None
        # Determine available graph file locations
        self.graph_file: Optional[Path] = None
        # Preferred legacy location
        legacy_graph = self.lrel_dir / 'relationship_graph.graphml'
        # Current production artifact seen in real data
        root_graph = self.input_dir / 'Lrel.graphml'
        if legacy_graph.exists():
            self.graph_file = legacy_graph
        elif root_graph.exists():
            self.graph_file = root_graph

        if self.logger:
            if self.graph_file:
                self.logger.info(
                    f"L_rel reader initialized: using graph file {self.graph_file}")
            else:
                self.logger.warning(
                    "L_rel reader initialized: no graph file found (optional).",
                    tried_paths=[str(legacy_graph), str(root_graph)]
                )
    
    def load_graph(self) -> nx.Graph:
        """
        Load relationship graph from GraphML file.
        
        Returns:
            NetworkX Graph instance
        """
        # Resolve graph file path (already determined in __init__)
        graphml_file = self.graph_file
        if graphml_file is None or not Path(graphml_file).exists():
            raise FileNotFoundError(
                f"GraphML file not found. Tried: {[str(self.lrel_dir / 'relationship_graph.graphml'), str(self.input_dir / 'Lrel.graphml')]}"
            )
        
        if self.logger:
            self.logger.info(f"Loading relationship graph from {graphml_file}")
        
        # Read GraphML file
        self.graph = nx.read_graphml(graphml_file)
        
        # Calculate metrics
        self.metrics = self._calculate_metrics()
        
        if self.logger:
            self.logger.info(
                "Relationship graph loaded",
                nodes=self.metrics.node_count,
                edges=self.metrics.edge_count,
                relationship_types=len(self.metrics.relationship_types)
            )
        
        return self.graph
    
    def _calculate_metrics(self) -> RelationshipMetrics:
        """Calculate graph metrics"""
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        # Extract relationship types from edges
        relationship_types = set()
        for u, v, data in self.graph.edges(data=True):
            if 'type' in data:
                relationship_types.add(data['type'])
            if 'relationship_type' in data:
                relationship_types.add(data['relationship_type'])
        
        # Calculate metrics
        node_count = self.graph.number_of_nodes()
        edge_count = self.graph.number_of_edges()
        
        average_degree = (2 * edge_count / node_count) if node_count > 0 else 0.0
        density = nx.density(self.graph)
        # For directed graphs, use weak connectivity; for undirected, standard connectivity
        if node_count > 0:
            try:
                if getattr(self.graph, 'is_directed', lambda: False)():
                    is_connected = nx.is_weakly_connected(self.graph)
                else:
                    is_connected = nx.is_connected(self.graph)
            except Exception as conn_err:
                # Be permissive: if connectivity check fails due to graph type, fall back to undirected view
                undirected = self.graph.to_undirected()
                is_connected = nx.is_connected(undirected) if undirected.number_of_nodes() > 0 else False
        else:
            is_connected = False
        
        return RelationshipMetrics(
            node_count=node_count,
            edge_count=edge_count,
            relationship_types=relationship_types,
            average_degree=average_degree,
            density=density,
            is_connected=is_connected
        )
    
    def get_entity_relationships(
        self,
        entity_id: str,
        relationship_type: Optional[str] = None
    ) -> List[Tuple[str, str, Dict[str, Any]]]:
        """
        Get all relationships for a specific entity.
        
        Args:
            entity_id: Entity identifier
            relationship_type: Optional filter by relationship type
        
        Returns:
            List of (source, target, attributes) tuples
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        if entity_id not in self.graph:
            return []
        
        relationships = []
        
        # Get all edges connected to this entity
        for neighbor in self.graph.neighbors(entity_id):
            edge_data = self.graph[entity_id][neighbor]
            
            # Filter by relationship type if specified
            if relationship_type:
                edge_type = edge_data.get('type') or edge_data.get('relationship_type')
                if edge_type != relationship_type:
                    continue
            
            relationships.append((entity_id, neighbor, edge_data))
        
        return relationships
    
    def get_entities_by_type(self, entity_type: str) -> List[str]:
        """
        Get all entity IDs of a specific type.
        
        Args:
            entity_type: Type of entity (e.g., 'course', 'faculty', 'room')
        
        Returns:
            List of entity IDs
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        entities = []
        for node, data in self.graph.nodes(data=True):
            node_type = data.get('type') or data.get('entity_type')
            if node_type == entity_type:
                entities.append(node)
        
        return entities
    
    def get_relationship_weight(self, source: str, target: str) -> Optional[float]:
        """
        Get weight of relationship between two entities.
        
        Args:
            source: Source entity ID
            target: Target entity ID
        
        Returns:
            Relationship weight or None if no relationship exists
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        if not self.graph.has_edge(source, target):
            return None
        
        edge_data = self.graph[source][target]
        return edge_data.get('weight', 1.0)
    
    def find_path(
        self,
        source: str,
        target: str,
        max_length: Optional[int] = None
    ) -> Optional[List[str]]:
        """
        Find shortest path between two entities.
        
        Args:
            source: Source entity ID
            target: Target entity ID
            max_length: Maximum path length
        
        Returns:
            List of entity IDs forming path, or None if no path exists
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        try:
            if max_length:
                path = nx.shortest_path(
                    self.graph,
                    source,
                    target,
                    weight='weight'
                )
                if len(path) <= max_length + 1:  # +1 because path includes endpoints
                    return path
                return None
            else:
                return nx.shortest_path(self.graph, source, target, weight='weight')
        except nx.NetworkXNoPath:
            return None
    
    def get_connected_component(self, entity_id: str) -> Set[str]:
        """
        Get all entities in the same connected component.
        
        Args:
            entity_id: Entity identifier
        
        Returns:
            Set of entity IDs in same component
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        if entity_id not in self.graph:
            return set()
        
        # Find connected component containing this entity
        for component in nx.connected_components(self.graph):
            if entity_id in component:
                return component
        
        return {entity_id}
    
    def get_subgraph(
        self,
        entity_ids: List[str],
        include_neighbors: bool = False
    ) -> nx.Graph:
        """
        Extract subgraph containing specified entities.
        
        Args:
            entity_ids: List of entity IDs to include
            include_neighbors: Also include direct neighbors
        
        Returns:
            Subgraph as NetworkX Graph
        """
        if self.graph is None:
            raise ValueError("Graph not loaded")
        
        nodes_to_include = set(entity_ids)
        
        if include_neighbors:
            for entity_id in entity_ids:
                if entity_id in self.graph:
                    nodes_to_include.update(self.graph.neighbors(entity_id))
        
        return self.graph.subgraph(nodes_to_include).copy()
    
    def get_metrics(self) -> Optional[RelationshipMetrics]:
        """Get graph metrics"""
        return self.metrics
    
    def get_summary(self) -> Dict[str, Any]:
        """
        Get summary of relationship graph.
        
        Returns:
            Summary dictionary
        """
        if self.metrics is None:
            return {"status": "not_loaded"}
        
        return {
            "status": "loaded",
            **self.metrics.to_dict()
        }


