"""
L_idx Reader for Stage 3 Index Structures

Reads index structures from Pickle files generated by Stage 3.

Theoretical Foundation:
- Stage-3 DATA COMPILATION - Theoretical Foundations & Mathematical Framework
- Section: L_idx Layer - Index Structures for O(1) Lookups
"""

import pickle
from pathlib import Path
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass


@dataclass
class IndexMetrics:
    """Metrics for index structures"""
    hash_indices_count: int
    tree_indices_count: int
    graph_indices_count: int
    bitmap_indices_count: int
    total_memory_mb: float
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "hash_indices": self.hash_indices_count,
            "tree_indices": self.tree_indices_count,
            "graph_indices": self.graph_indices_count,
            "bitmap_indices": self.bitmap_indices_count,
            "total_memory_mb": self.total_memory_mb,
        }


class LIdxReader:
    """
    Reader for L_idx Pickle files from Stage 3 output.
    
    L_idx contains four types of index structures:
    1. Hash Indices: O(1) lookups by primary key
    2. Tree Indices: O(log n) range queries and sorted access
    3. Graph Indices: Relationship traversal indices
    4. Bitmap Indices: Fast filtering for categorical attributes
    
    These indices enable efficient data access during optimization.
    """
    
    INDEX_FILES = {
        'hash': 'hash_indices.pkl',
        'tree': 'tree_indices.pkl',
        'graph': 'graph_indices.pkl',
        'bitmap': 'bitmap_indices.pkl',
    }
    
    def __init__(self, input_dir: Path, logger: Optional[Any] = None):
        """
        Initialize L_idx reader.
        
        Args:
            input_dir: Path to Stage 3 output directory
            logger: Optional StructuredLogger instance
        """
        self.input_dir = Path(input_dir)
        # Support both legacy L_idx/ and current indices/
        legacy_dir = self.input_dir / 'L_idx'
        new_dir = self.input_dir / 'indices'
        self.lidx_dir = legacy_dir if legacy_dir.exists() else new_dir
        self.logger = logger
        
        # Loaded indices
        self.hash_indices: Optional[Dict[str, Any]] = None
        self.tree_indices: Optional[Dict[str, Any]] = None
        self.graph_indices: Optional[Dict[str, Any]] = None
        self.bitmap_indices: Optional[Dict[str, Any]] = None
        
        self.metrics: Optional[IndexMetrics] = None
        
        # Validation
        if not self.lidx_dir.exists():
            raise FileNotFoundError(f"L_idx/indices directory not found: {self.lidx_dir}")
        
        if self.logger:
            self.logger.info(f"L_idx reader initialized: {self.lidx_dir}")
    
    def load_all_indices(self) -> Dict[str, Any]:
        """
        Load all index structures from Pickle files.
        
        Returns:
            Dictionary containing all index structures
        """
        if self.logger:
            self.logger.info("Loading all L_idx index structures")
        
        indices = {}
        
        # Load hash indices
        try:
            self.hash_indices = self._load_pickle(self.INDEX_FILES['hash'])
            indices['hash'] = self.hash_indices
            if self.logger:
                self.logger.debug(f"Loaded hash indices: {len(self.hash_indices)} entities")
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to load hash indices: {e}")
        
        # Load tree indices
        try:
            self.tree_indices = self._load_pickle(self.INDEX_FILES['tree'])
            indices['tree'] = self.tree_indices
            if self.logger:
                self.logger.debug(f"Loaded tree indices: {len(self.tree_indices)} entities")
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to load tree indices: {e}")
        
        # Load graph indices (prefer new filename if present)
        try:
            graph_new = 'Lidx_relationship_graph.pkl'
            graph_legacy = self.INDEX_FILES['graph']
            try:
                self.graph_indices = self._load_pickle(graph_new)
            except Exception:
                self.graph_indices = self._load_pickle(graph_legacy)
            indices['graph'] = self.graph_indices
            if self.logger:
                self.logger.debug(f"Loaded graph indices")
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to load graph indices: {e}")
        
        # Load bitmap indices
        try:
            self.bitmap_indices = self._load_pickle(self.INDEX_FILES['bitmap'])
            indices['bitmap'] = self.bitmap_indices
            if self.logger:
                self.logger.debug(f"Loaded bitmap indices: {len(self.bitmap_indices)} entities")
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to load bitmap indices: {e}")
        
        # Calculate metrics
        self.metrics = self._calculate_metrics()
        
        if self.logger:
            self.logger.info(
                "All indices loaded",
                **self.metrics.to_dict()
            )
        
        return indices
    
    def _load_pickle(self, filename: str) -> Any:
        """Load pickle file"""
        pickle_file = self.lidx_dir / filename
        
        if not pickle_file.exists():
            raise FileNotFoundError(f"Index file not found: {pickle_file}")
        
        with open(pickle_file, 'rb') as f:
            return pickle.load(f)
    
    def _calculate_metrics(self) -> IndexMetrics:
        """Calculate index metrics"""
        import sys
        
        hash_count = len(self.hash_indices) if self.hash_indices else 0
        tree_count = len(self.tree_indices) if self.tree_indices else 0
        graph_count = 1 if self.graph_indices else 0
        bitmap_count = len(self.bitmap_indices) if self.bitmap_indices else 0
        
        # Estimate memory usage
        total_memory = 0
        if self.hash_indices:
            total_memory += sys.getsizeof(self.hash_indices)
        if self.tree_indices:
            total_memory += sys.getsizeof(self.tree_indices)
        if self.graph_indices:
            total_memory += sys.getsizeof(self.graph_indices)
        if self.bitmap_indices:
            total_memory += sys.getsizeof(self.bitmap_indices)
        
        total_memory_mb = total_memory / (1024 * 1024)
        
        return IndexMetrics(
            hash_indices_count=hash_count,
            tree_indices_count=tree_count,
            graph_indices_count=graph_count,
            bitmap_indices_count=bitmap_count,
            total_memory_mb=total_memory_mb
        )
    
    def lookup_by_id(self, entity_type: str, entity_id: str) -> Optional[Any]:
        """
        O(1) lookup by entity ID using hash index.
        
        Args:
            entity_type: Type of entity (e.g., 'course', 'faculty')
            entity_id: Entity identifier
        
        Returns:
            Entity data or None if not found
        """
        if self.hash_indices is None:
            raise ValueError("Hash indices not loaded")
        
        if entity_type not in self.hash_indices:
            return None
        
        return self.hash_indices[entity_type].get(entity_id)
    
    def range_query(
        self,
        entity_type: str,
        attribute: str,
        min_value: Any,
        max_value: Any
    ) -> List[Any]:
        """
        O(log n) range query using tree index.
        
        Args:
            entity_type: Type of entity
            attribute: Attribute to query
            min_value: Minimum value (inclusive)
            max_value: Maximum value (inclusive)
        
        Returns:
            List of matching entities
        """
        if self.tree_indices is None:
            raise ValueError("Tree indices not loaded")
        
        if entity_type not in self.tree_indices:
            return []
        
        if attribute not in self.tree_indices[entity_type]:
            return []
        
        # Tree index should support range queries
        tree_index = self.tree_indices[entity_type][attribute]
        
        # Implementation depends on tree structure (e.g., B-tree, sorted list)
        # For now, return empty list (to be implemented based on actual structure)
        return []
    
    def filter_by_bitmap(
        self,
        entity_type: str,
        attribute: str,
        value: Any
    ) -> Set[str]:
        """
        Fast filtering using bitmap index.
        
        Args:
            entity_type: Type of entity
            attribute: Categorical attribute
            value: Value to filter by
        
        Returns:
            Set of entity IDs matching filter
        """
        if self.bitmap_indices is None:
            raise ValueError("Bitmap indices not loaded")
        
        if entity_type not in self.bitmap_indices:
            return set()
        
        if attribute not in self.bitmap_indices[entity_type]:
            return set()
        
        bitmap_index = self.bitmap_indices[entity_type][attribute]
        return bitmap_index.get(value, set())
    
    def get_summary(self) -> Dict[str, Any]:
        """
        Get summary of loaded indices.
        
        Returns:
            Summary dictionary
        """
        if self.metrics is None:
            return {"status": "not_loaded"}
        
        return {
            "status": "loaded",
            **self.metrics.to_dict()
        }


